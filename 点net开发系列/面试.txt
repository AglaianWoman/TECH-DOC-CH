数据库索引，性能，大数据量处理

 数据库优化
1.查询利用率
建立索引（适用10W左右的条目数）经历，首先要判断此表的利用率：

1）先进行插入后建立索引，正常的情况是我们喜欢老进行查询字段（建立索引增加查询效率）：
比如，我有20W条数据，我想查询这些数据，但是呢我就会想到底是先插入数据后建立索引好呢，还是先建立索引后插入数据好呢？答案是这样的我们最好是先进行插入数据，后进行建立索引，原因是插入数据的时候我们不会受索引影响，不需要在插入的时候让索引如果我们再把插入的数据与索引结合，重新整理，相反如果先插入数据后建立索引，我们不会受索引的影响，就是正常的插入数据，然后再找个晚上下班后让机器自己建立索引。

2）：如果我们在用这个表的时候不是查询，而是做DML 那么我们就需要比较考虑一点，最好不要建立索引，第一会降低DML的效率，第二索引本就是用于查询的，DML多的表建立索引没事找抽。
3）：尽量少应用from * 一起查询出来太慢。
4）建立索引的时候需要校验:此字段不包含null值。如果要查询字段的数据上是NULL 那么建立索引的时候一定是失效的，因为这个NULL在建立索引的时候不知道布局应该给NULL放在哪里，。
5）索引有的时候是无效的：
-使用<>比较时，索引无效，建议使用< or >
-使用前置模糊匹配%时无效,建议使用 instr
-使用函数（解决：创建基于函数的索引）create index indexname on emp(upper(name));大写
-使用不匹配的数据类型
6）建立分区表：如果表特别大（适用上500万级），那么在建立索引之前，需要建立分区表，按照一定的规则为表进行分区，例子：电话所属地，黑龙江的城市分区，查询一个号，比如查询哈尔滨的号，那么就会在这个分区表中的哈尔滨区，进行查询。
2、DML表的利用率：
1）扩大表空间（）如果表空间利用率低的话那么在使用DML的时候我们就会特别慢，解决方式是手动提高表空间。
①临时表空间：（适用于查询）就是查询出的数据需要进行存放，再展示到前台的表空间。
②数据表空间：（适用于DML）仅仅保存数据文件的。扩大表空间的时候就是扩大数据表空间。
③UNDO表空间：（适用于DML）在COMMIT和ROLLBACK之前的时候，我们数据存在了哪里呢？就存在了UNDO表空间，
2）在经常DML表中添加了索引,这就需要我们把经常DML表删除此索引。
3）考虑INSERT语句，没有必要插入的字段不进行插入。
4）最后考虑硬件问题了。




上一篇 下一篇 返回上页首页 
1
字体大小: 小 中 大日期: 2011-09-22 13:49:52 
Java基础方面: 

1、作用域public,private,protected,以及不写时的区别 

答：区别如下： 

作用域 当前类 同一package 子孙类 其他package 

public √ √ √ √ 

protected √ √ √ × 

friendly √ √ × × 

private √ × × × 

不写时默认为friendly 

 

2、ArrayList和Vector的区别,HashMap和Hashtable的区别 

答：就ArrayList与Vector主要从二方面来说. 

一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的 

二.数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半 

就HashMap与HashTable主要从三方面来说。 

一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 

二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 

三.值：只有HashMap可以让你将空值作为一个表的条目的key或value 

 

3、char型变量中能不能存贮一个中文汉字?为什么? 

答：是能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的 


4、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? 

答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 

同步的实现方面有两种，分别是synchronized,wait与notify 

17、STRING与STRINGBUFFER的区别。 

答：STRING的长度是不可变的，STRINGBUFFER的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用StringBuffer，如果最后需要String，那么使用StringBuffer的toString()方法 

 

4、&和&&的区别 3-3
答：&是位运算符，表示按位与运算，&&是逻辑运算符，表示逻辑与（and）
5、Collection 和 Collections的区别
答：Collection是集合类的上级接口，继承与他的接口主要有Set 和List.
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作

7、String s = new String("xyz");创建了几个String Object
答：两个，一个字符对象，一个字符对象引用对象

12、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型
答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型

17、abstract class和interface有什么区别
答：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法
接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口

抽象类：只能被一个类继承 有自己的实现体（非抽象和抽象的方法）

接口：是一个实现的关系 必须都是抽象的方法 属性必须是静态的

23、用最有效率的方法算出2乘以8等於几
答：2 << 3

34、谈谈final, finally, finalize的区别
答：final―修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载
finally―再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）
finalize―方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的

36、String是最基本的数据类型吗
答：基本数据类型包括byte、int、char、long、float、double、boolean和short。
java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类

39、说出ArrayList,Vector, LinkedList的存储性能和特性
答：ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

事务：

原子性（Atomic）：
指整个数据库事务是不可分割的工作单元。原子性确保在事务中所有操作都发生或都失败
一致性（Consistency）：
一旦一个事务结束了（不管成功与否），系统所处的状态和他的业务规则是一致的。即数据不会被破坏。
隔离性（Isolation）：
指多个事务同时操作同一数据时，每个事务都有各自的完整数据空间。
持久性（Durability）：
一旦事务完成，事务的结果应该持久化。


